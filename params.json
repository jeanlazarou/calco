{"name":"Calco","tagline":"Implements a DSL used to create and define the content of spreadsheet documents","body":"# Calco\r\n\r\nI started this project after spending time once again on code generating `CSV`\r\nfiles that we open with a spreadsheet software, add formatting, calculations, \r\netc. The final spreadsheet document is a tool for the users with the current \r\ndata snapshot.\r\n\r\nThe code generating the `CSV` file can run several times but we have to manually\r\nre-create the spreadsheet document.\r\n\r\n*Calco* tries to separate the data from the spreadsheet presentation and the all\r\nthe calculations.\r\n\r\n*Calco* implements a DSL (domain specific language) that abstracts the \r\ncalculations and the basic needs for styling and formatting.\r\n\r\nIt generates a spreadsheet document in different formats depending on the \r\nselected engine.\r\n\r\nThe output depends on the engine. The office ([*LibreOffice*](https://www.libreoffice.org)\r\nor [*OpenOffice*](http://www.openoffice.org/)) engine uses an input document as \r\ntemplate for more sophisticated layouts. The `DefaultEngine` writes simple text \r\nuseful to check the spreadsheet definition.\r\n\r\nA spreadsheet contains one or more sheets.\r\n\r\nA sheet contain cells (viewed as rows and columns).\r\n\r\nA cell can contain:\r\n\r\n* literal values (like numbers, dates, times or strings)\r\n* references to other cells\r\n* formulas or functions combining literal values, references, conditionals, \r\narithmetics expressions and calls to built-in functions\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'calco'\r\n```\r\n\r\nAnd then execute:\r\n\r\n```bash\r\n$ bundle\r\n```\r\n\r\nOr install it as:\r\n\r\n```bash\r\n$ gem install calco\r\n```\r\n\r\n## Usage\r\n\r\n### Running the specification:\r\n\r\n```bash\r\n$ rspec spec\r\n```\r\n    \r\nTry running specifications with format output...\r\n\r\n```bash\r\n$ rspec -f d\r\n```\r\n\r\n### Running the examples:\r\n\r\n```bash\r\n$ ruby examples/example.rb\r\n```\r\n\r\nReplace the `example.rb` with any file of the example directory.\r\n\r\n#### Example files (in order of *complexity*)\r\n\r\n* [examples/using_date_functions.rb](examples/using_date_functions.rb)\r\n* [examples/example.rb](examples/example.rb)\r\n* [examples/multiplication_tables.rb](examples/multiplication_tables.rb)\r\n* [examples/compute_cells.rb](examples/compute_cells.rb)\r\n* [examples/write_csv.rb](examples/write_csv.rb)\r\n* [examples/write_ods.rb](examples/write_ods.rb)\r\n* [examples/register_function.rb](examples/register_function.rb)\r\n\r\n## Quick start\r\n\r\nLet's review the [using_date_functions.rb](examples/using_date_functions.rb)\r\nexample.\r\n\r\nThe code must first require some files, like `date` as the example is using \r\ndates.\r\n\r\n```ruby\r\nrequire 'date'\r\nrequire 'calco'\r\n```\r\n\r\nNow, create the document definition.\r\n\r\n```ruby\r\ndoc = spreadsheet do\r\n\r\n  definitions do\r\n\r\n    set some_date: Date.today\r\n\r\n    function some_year: year(some_date)\r\n    function age: year(today) - year(some_date)\r\n    \r\n  end\r\n  \r\n  sheet do\r\n\r\n    column value_of(:some_date)\r\n\r\n    column :some_year\r\n    column :age\r\n\r\n  end\r\n\r\nend\r\n```\r\n\r\nThe above code uses the spreadsheet method that returns a document created using \r\nthe given definition (the code block).\r\n\r\nThe definition contains two parts: the `definitions` and the `sheet`.\r\n\r\nThe *definitions* part contains all the *variable* declarations (see \r\n`set some_date`) and the functions (see `some_year` and `age`).\r\n\r\nThe *sheet* part describes the content of the sheet columns. Here the first \r\ncolumns is going to contain the value of the `some_date` variable and the next \r\ntwo columns will contain the functions, so that the final spreadsheet is going \r\nto compute the values using the functions/formulas.\r\n\r\nThe last part writes the result to the console (using the `$stdout` variable).\r\n\r\n```ruby\r\ndoc.save($stdout) do |spreadsheet|\r\n\r\n  sheet = spreadsheet.current\r\n  \r\n  sheet[:some_date] = Date.new(1934, 10, 3)\r\n  sheet.write_row 3\r\n  \r\n  sheet[:some_date] = Date.new(2004, 6, 19)\r\n  sheet.write_row 5\r\n  \r\nend\r\n```\r\n\r\nSaving a document involves calling the `save` method with a block. The block \r\nreceives a spreadsheet object. A spreadsheet object has a current sheet. We can \r\nassign values to the existing variables (see `sheet[:some_date]` statements) and \r\nask the spreadsheet to write a row (passing the index of the row), see \r\n`sheet.write_row 3`.\r\n\r\nThe object passed to the block is the same as the one called to save, next code \r\nis doing the same thing.\r\n\r\n```ruby\r\ndoc.save($stdout) do\r\n\r\n  sheet = doc.current\r\n  \r\n  sheet[:some_date] = Date.new(1934, 10, 3)\r\n  sheet.write_row 3\r\n  \r\n  sheet[:some_date] = Date.new(2004, 6, 19)\r\n  sheet.write_row 5\r\n  \r\nend\r\n```\r\n\r\nThe final output is:\r\n\r\n    A3: 1934-10-03\r\n    B3: YEAR(A3)\r\n    C3: YEAR(TODAY())-YEAR(A3)\r\n\r\n    A5: 2004-06-19\r\n    B5: YEAR(A5)\r\n    C5: YEAR(TODAY())-YEAR(A5)\r\n\r\n## Definitions\r\n\r\nAs explained in the previous example, building a spreadsheet object requires to\r\nsetup the definitions. What can a definition block contain?\r\n\r\nFirst see the definitions specs: [spec/definitions_spec.rb](spec/definitions_spec.rb)\r\n\r\n### Values, variables, references and functions\r\n\r\nSee specifications\r\n\r\n* [spec/variables_spec.rb](spec/variables_spec.rb)\r\n* [spec/absolute_references_spec.rb](spec/absolute_references_spec.rb)\r\n* [spec/conditions_spec.rb](spec/conditions_spec.rb)\r\n* [spec/functions_spec.rb](spec/functions_spec.rb)\r\n* [spec/errors_spec.rb](spec/errors_spec.rb)\r\n* [spec/smart_types_spec.rb](spec/smart_types_spec.rb)\r\n* [spec/builtin_functions_spec.rb](spec/builtin_functions_spec.rb)\r\n\r\n### Aggregations...\r\n\r\nSee specifications\r\n\r\n* [spec/range_spec.rb](spec/range_spec.rb)\r\n\r\n### Sheet manipulation\r\n\r\nSee specifications\r\n\r\n* [spec/sheet_spec.rb](spec/sheet_spec.rb)\r\n* [spec/sheet_selections_spec.rb](spec/sheet_selections_spec.rb)\r\n* [spec/spreadsheet_spec.rb](spec/spreadsheet_spec.rb)\r\n* [spec/content_change_spec.rb](spec/content_change_spec.rb)\r\n\r\n### Styles\r\n\r\nSee specifications\r\n\r\n* [spec/styles_spec.rb](spec/styles_spec.rb)\r\n\r\n### Engines\r\n\r\nSee specifications\r\n\r\n* [spec/default_engine_spec.rb](spec/default_engine_spec.rb)\r\n* [spec/csv_engine_spec.rb](spec/csv_engine_spec.rb)\r\n* [spec/calculator_engine_spec.rb](spec/calculator_engine_spec.rb)\r\n\r\n## LibreOffice engine\r\n\r\nThe office engine uses a template file when it writes the output file. It \r\nsearches for each sheet a template sheet in the template file after its name.\r\n\r\nIf the engine finds a template sheet, it removes the content and inserts the\r\ngenerated rows. If the template sheet contains the header, the engine does\r\nnot remove it (using the `has_titles` directive).\r\n\r\nIf the engine does not find a template sheet, it appends a new sheet.\r\n\r\nHere is an example:\r\n\r\n```ruby\r\nengine = Calco::OfficeEngine.new('names.ods')\r\n\r\ndoc = spreadsheet(engine) do\r\n\r\n  definitions do\r\n\r\n    set name: ''\r\n    \r\n  end\r\n  \r\n  sheet('Main') do\r\n\r\n    has_titles true\r\n\r\n    column value_of(:name)\r\n\r\n  end\r\n  \r\nend\r\n```\r\n\r\nThe code creates an office engine and sets a template files named `names.ods`.\r\n\r\nThe spreadsheet definition defines a sheet named _Main_ and says that the\r\ntemplate sheet contains the header row (see `has_titles true`).\r\n\r\n## Tips\r\n\r\n### Titles row...\r\n\r\nThe words *title* or *header* to refer to the first row of a sheet that\r\nrepresent the columns names or labels...\r\n\r\nBecause spreadsheets do not use row 0, row 0 (using the Sheet#row method) \r\nreturns headers or empty if no header is set (see \r\n[spec/header_row_spec.rb](spec/header_row_spec.rb)).\r\n\r\nA sheet is marked as having a header row (a first row with titles) by using\r\nthe `:title` option or the `has_titles` method.\r\n\r\nThe use of the header row depends on the engine (the office engine does not\r\nwrite the column titles).\r\n\r\nThe effect is that, if the sheet is marked as having a titles row, the data \r\noutput starts at index 2, remember 0 is the header row. Otherwise the data \r\nstarts at index 1. It is important because the formulas contain references like\r\n`A<n>` and `n` must start at 1 if the first row does not contain headers.\r\n\r\n### Saving as CSV files\r\n\r\nThe CSV engine writes files containing formulas (functions) instead of computing\r\nthe values. Also, for values like dates and times, it uses function instead of \r\nplain strings. If you open the CSV file with *LibreOffice* (or *OpenOffice*) it \r\nrecognizes the functions so that you do no loose the benefit of having \r\nformulas/functions.\r\n\r\nAs an example the output of [examples/write_csv.rb](examples/write_csv.rb) is\r\n\r\n```\r\nStart,End,Duration\r\n\"=TIMEVALUE(\"\"12:10:00\"\")\",\"=TIMEVALUE(\"\"15:30:00\"\")\",=B2-A2\r\n\"=TIMEVALUE(\"\"11:00:00\"\")\",\"=TIMEVALUE(\"\"16:30:00\"\")\",=B3-A3\r\n\"=TIMEVALUE(\"\"10:01:00\"\")\",\"=TIMEVALUE(\"\"12:05:00\"\")\",=B4-A4\r\n\"\",\"\",=SUM(C1:C4)\r\n```\r\n\r\nIf you open the file with *LibreOffice* you get something like\r\n\r\n```\r\nStart     End       Duration\r\n12:10:00  15:30:00  03:20:00\r\n11:00:00  16:30:00  05:30:00\r\n10:01:00  12:05:00  02:04:00\r\n                    10:54:00\r\n```\r\n\r\nThe time values are real time values, not strings. The formulas are computed.\r\n\r\n## Todo\r\n\r\n1. cross-sheet references\r\n2. specs for office engine\r\n   * currencies\r\n   * percentages\r\n   * time\r\n   * date, now\r\n   * absolute $A$5\r\n   * styles (both formulas and values)\r\n3. CSV engine (using the calculator)\r\n\r\n## Done\r\n\r\n1. specs: func not found, add func, func arity (also check error)\r\n2. build-in function, improve with function registration with types and args,\r\ncreate `date_functions.rb`, etc.\r\n3. replace \"Left\" function implementation with build-in mechanism\r\n4. add example showing the function registration\r\n5. split into files...\r\n6. improve ugly code in 'element.rb)'\r\n7. refactor document 'save'\r\n8. 'DefaultEngine' should implement 'save' method\r\n9. add a 'calculator' engine (as an example)\r\n1. simple calculator engine should use internal context for computation\r\n1. specs for simple calculator engine\r\n  * string values\r\n  * with titles and function\r\n  * column title/names => used in output\r\n  * absolute cells reference\r\n  * skip cells\r\n12. spreadsheets have no row '0', 0 always refers to header row\r\n13. specs for errors\r\n    * err: unknown var\r\n    * err: unknown function\r\n    * err: assign the same var twice\r\n    * err: declare the function and var twice\r\n    * err: ArgumentError => `column :price, 'pp'` ('title:' missing)\r\n    * err: column id not found\r\n14. specs for sheet\r\n    * accept expressions like: `function actual_price: 1 + (tax_rate / 100)`\r\n    * last sheet is current\r\n    * setting current sheet => `doc.sheet(\"a\").current`\r\n15. ids for columns\r\n    * err: id for column not found\r\n16. spec for CSV engine\r\n    * `=DOLLAR(A1,2)`\r\n    * `=SUM(A1:A3)`\r\n    * DOLLAR for formula cell\r\n    * DOLLAR and include conditional style `=DOLLAR((A3/100)+STYLE(IF(CURRENT()>3,\"Red\",\"Green\")))`\r\n    * % type specification\r\n17. specs for Spreadsheet\r\n    * Spreadsheet#row(n) returns value of current sheet\r\n18. removed engine explicit dependency for Element(s), engine is injected by\r\n    sheets using Sheet#compile\r\n19. fixed elements generate methods that did not return values using engine\r\n20. spec for default engine\r\n    * skip columns, sheet#row returns ''\r\n21. API to change engine\r\n22. changed office example to use conditional styles\r\n23. added `empty_row` (in all engines)\r\n24. explained examples in top of files\r\n25. wrote a gem description, reused examples\r\n26. use formula when applying dynamic styles to values\r\n27. mutliple sheets\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}